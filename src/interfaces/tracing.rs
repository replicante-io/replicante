use opentracingrust::Tracer;
use opentracingrust::utils::ReporterThread;

use slog::Logger;

use replicante_util_tracing::Config;
use replicante_util_tracing::TracerExtra;
use replicante_util_tracing::tracer;

use super::Result;


/// Distributed tracing interface.
pub struct Tracing {
    tracer: Tracer,

    // Below attributes are consumed or generated by `Tracing::run` and `Tracing::wait`.
    _reporter: Option<ReporterThread>,
}

impl Tracing {
    /// Creates a new `Tracing` interface.
    ///
    /// Configuring the tracer usually also start the
    /// reporting thread but this is backend dependent.
    pub fn new(config: Config, logger: Logger) -> Result<Tracing> {
        let (tracer, extra) = tracer(config, logger)?;
        let reporter = match extra {
            TracerExtra::Nothing => None,
            TracerExtra::ReporterThread(reporter) => Some(reporter),
        };
        Ok(Tracing {
            _reporter: reporter,
            tracer,
        })
    }

    /// Noop method for standard interface.
    pub fn run(&self) -> Result<()> {
        Ok(())
    }

    /// Access the stored [`Tracer`]
    ///
    /// [`Tracer`]: opentracingrust/struct.Tracer.html
    pub fn tracer(&self) -> &Tracer {
        &self.tracer
    }

    /// Noop method for standard interface.
    pub fn wait(&self) -> Result<()> {
        // ReporterThread is stopped and joined when dropped so we don't wait.
        Ok(())
    }
}
