use failure::ResultExt;
use opentracingrust::utils::ReporterThread;
use opentracingrust::Tracer;
use slog::Logger;

use replicante_util_tracing::tracer;
use replicante_util_tracing::Config;
use replicante_util_tracing::TracerExtra;

use super::ErrorKind;
use super::Result;

/// Distributed tracing interface.
pub struct Tracing {
    tracer: Tracer,

    // Below attributes are consumed or generated by `Tracing::run` and `Tracing::wait`.
    reporter: Option<ReporterThread>,
}

impl Tracing {
    /// Creates a new `Tracing` interface.
    ///
    /// Configuring the tracer usually also start the
    /// reporting thread but this is backend dependent.
    pub fn new(config: Config, logger: Logger) -> Result<Tracing> {
        let (tracer, extra) =
            tracer(config, logger).with_context(|_| ErrorKind::InterfaceInit("tracing"))?;
        let reporter = match extra {
            TracerExtra::Nothing => None,
            TracerExtra::ReporterThread(reporter) => Some(reporter),
        };
        Ok(Tracing { reporter, tracer })
    }

    /// Noop method for standard interface.
    pub fn run(&self) -> Result<()> {
        Ok(())
    }

    /// Access the stored [`Tracer`]
    ///
    /// [`Tracer`]: opentracingrust/struct.Tracer.html
    #[allow(unused)]
    pub fn tracer(&self) -> &Tracer {
        &self.tracer
    }

    /// Returns a `Tracing` instance usable as a mock.
    #[cfg(test)]
    pub fn mock() -> Tracing {
        let (tracer, receiver) = ::opentracingrust::tracers::NoopTracer::new();
        let reporter = ReporterThread::new_with_duration(
            receiver,
            ::std::time::Duration::from_millis(50),
            ::opentracingrust::tracers::NoopTracer::report,
        );
        Tracing {
            reporter: Some(reporter),
            tracer,
        }
    }
}

impl Drop for Tracing {
    fn drop(&mut self) {
        // Drop the reporter (and join the thread), if any, before we drop the tracer.
        drop(self.reporter.take());
    }
}
