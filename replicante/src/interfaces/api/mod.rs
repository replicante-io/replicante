//! HTTP API interface to interact with replicante.
//!
//! This interface is a wrapper around the [`iron`] framework.
//! This module does not implement all of the APIs but rather provides
//! tools for other interfaces and components to add their own endpoints.
use failure::ResultExt;
use humthreads::Builder as ThreadBuilder;
use humthreads::Thread;
use iron::Iron;
use iron_json_response::JsonResponseMiddleware;
use slog::Logger;

use replicante_util_iron::MetricsMiddleware;
use replicante_util_iron::RequestLogger;

use super::super::ErrorKind;
use super::super::Result;
use super::metrics::Metrics;


mod config;
mod metrics;
mod router;
mod routes;

pub use self::config::Config;
pub use self::metrics::register_metrics;
pub use self::router::VersionedRouter;

use self::metrics::MIDDLEWARE;
use self::router::RouterBuilder;


/// The replicante HTTP API interface.
pub struct API {
    config: Config,
    logger: Logger,

    // Below attributes are consumed or generated by `API::run` and `API::wait`.
    handle: Option<Thread<()>>,
    metrics_middleware: Option<MetricsMiddleware>,
    router: Option<RouterBuilder>,
}

impl API {
    /// Creates a new API interface.
    pub fn new(config: Config, logger: Logger, metrics: &Metrics) -> API {
        let registry = metrics.registry().clone();
        let mut router = RouterBuilder::new();
        routes::mount(&mut router, registry);

        let middleware = MetricsMiddleware::new(
            MIDDLEWARE.0.clone(), MIDDLEWARE.1.clone(), MIDDLEWARE.2.clone(), logger.clone()
        );

        API {
            config,
            logger,
            handle: None,
            metrics_middleware: Some(middleware),
            router: Some(router),
        }
    }

    /// Register routes for a specific API version.
    pub fn router_for(&mut self, version: APIVersion) -> VersionedRouter {
        self.router
            .as_mut()
            .expect("Unable to access router. Was API::run called already?")
            .for_version(version)
    }

    /// Creates an Iron server and spawns a thread to serve it.
    pub fn run(&mut self) -> Result<()> {
        let bind = self.config.bind.clone();
        let logger = self.logger.clone();

        let mut chain = self.router.take().unwrap().build();
        chain.link_after(JsonResponseMiddleware::new());
        chain.link_after(RequestLogger::new(self.logger.clone()));
        chain.link(self.metrics_middleware.take().unwrap().into_middleware());

        let handle = ThreadBuilder::new("r:i:api")
            .full_name("replicore:interface:api")
            .spawn(move |_scope| {
                info!(logger, "Starting API server"; "bind" => bind.clone());
                Iron::new(chain).http(bind).expect("Unable to start API server");
            })
            .context(ErrorKind::SpawnThread("http server"))?;
        self.handle = Some(handle);
        Ok(())
    }

    /// Wait for the server thread to stop.
    pub fn wait(&mut self) -> Result<()> {
        info!(self.logger, "Waiting for API server to stop");
        self.handle.take().map(|mut handle| handle.join());
        Ok(())
    }

    /// Returns an `API` instance usable as a mock.
    #[cfg(test)]
    pub fn mock(logger: Logger, metrics: &Metrics) -> API {
        let config = Config::default();
        API::new(config, logger, metrics)
    }
}

/// Enumerates all possible API versions.
///
/// All endpoints must fall under one of these versions and are subject to all restrictions
/// of that specific version.
/// The main restriction is that versioned APIs are subject to semver guarantees.
pub enum APIVersion {
    /// API version for all endpoints that are not yet stable.
    ///
    /// Endpoints in this root are NOT subject to ANY compatibility guarantees!
    Unstable,
}

impl APIVersion {
    /// API version prefix for route globs.
    fn prefix(&self) -> &'static str {
        match self {
            APIVersion::Unstable => "/api/unstable",
        }
    }
}
